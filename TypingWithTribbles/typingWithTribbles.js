const holes = document.querySelectorAll('.hole');
const scoreBoard = document.querySelector('.score');
let lastHole;
let lastKey;
let timeUp = false;
let score = 0;

// drum kit
const keys = Array.from(document.querySelectorAll('.key'));
// drum kit
keys.forEach(key => key.addEventListener('transitionend', removeTransition));

// tribbles.forEach(tribble => tribble.addEventListener('click', bonk));
keys.forEach(key => key.addEventListener('keydown', bonk));
window.addEventListener('keydown', playSound);
$('.game').hide();
$('.keys').hide();


function startGame() {

    $('.intro').hide();
    $('.game').show();
    $('.keys').show();

    scoreBoard.textContent = 0;
    timeUp = false;
    score = 0;
    beginAnimations();
    // playSound();
    lightRandomKey();
    setTimeout(() => timeUp = true, 20000)
}

function randomKey(keys) {
    const idx = Math.floor(Math.random() * keys.length);
    const key = keys[idx];
    if (key === lastKey) {
        console.log('Ah nah thats the same key bud');
        return randomKey(keys);
    }
    lastKey = key;
    return key;
}

function lightRandomKey() {
    const time = randomTime(200, 1000);
    const key = randomKey(keys);
    key.classList.add('hitMe');
    setTimeout(() => {
        // savea a variable so you can cancel it if you need to
        key.classList.remove('hitMe');
        key.classList.remove('playing');
        if (!timeUp) lightRandomKey();
    }, time);
}

//isTrusted read-only property of the Event interface is a boolean that is true when the event was generated by a user action, and false when the event was created or modified by a script or dispatched via dispatchEvent.
function bonk(e) {
    if (!e.isTrusted) return;
    console.log("bonk");
    score++;
    keys.classList.remove('hitMe');
    this.classList.remove('drop');
    scoreBoard.textContent = score;

    if (key === lastKey) {
        console.log('Ah nah thats the same key bud');
        return randomKey(keys);
    }
}

function removeTransition(e) {
    if (e.propertyName !== 'transform') return;
    e.target.classList.remove('playing');
}

function playSound(e) {
    const audio = document.querySelector(`audio[data-key="${e.keyCode}"]`);
    const key = document.querySelector(`div[data-key="${e.keyCode}"]`);
    if (!audio) return;

    key.classList.add('playing');
    audio.currentTime = 0;
    audio.play();
}

function randomTime(min, max) {
    return Math.round(Math.random() * (max - min) + min);
}

function randomHole(holes) {
    var idx = Math.floor(Math.random() * holes.length);
    var hole = holes[idx];
    if (hole === lastHole) {
        console.log('Ah nah thats the same one bud');
        return randomHole(holes);
    }
    lastHole = hole;

    return hole;
}


function beginAnimations() {
    queueNextAnimation(randomTime(200, 1000));
}

function queueNextAnimation(delay){
    setTimeout(() => {
        // savea a variable so you can cancel it if you need to
        var hole = randomHole(holes);
        if (!timeUp) dropFunction(hole);
        queueNextAnimation(randomTime(200, 1000));
    }, delay);
}

function dropFunction(holeElem) {
    var elem = holeElem.querySelector('.tribble:not(.drop)');

    if(!elem){
        return;
    }
    elem.classList.add('drop');
    var pos = -70;
    var id = setInterval(frame, 5);
    function frame() {
        if (pos == elem.parentElement.getBoundingClientRect().height){
            clearInterval(id);
            elem.classList.remove('drop');
            elem.style.top = "-70px";
        } else {
            pos++;
            elem.style.top = pos + 'px';
            // elem.style.width = 1 + Number.parseInt(elem.style.width.match(/^\d+/)) + 'px';
        }
    }
}